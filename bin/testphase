#!/usr/bin/env php
<?php
/**
 * Copyright 2015 Spafaridis Xenofon
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

$autoload = [
    __DIR__ . '/../vendor/autoload.php',
    __DIR__ . '/../../../autoload.php' //When used from vendor/bin
];

if (file_exists($autoload[0])) {
    include $autoload[0];
} elseif (file_exists($autoload[1])) {
    include $autoload[1];
} else {
    echo 'ERROR, autoload not found' . PHP_EOL;
    exit(1);
}

use \Phramework\Testphase\Testphase;
use \Phramework\Testphase\TestParser;
use \Phramework\Models\Util;
use \GetOptionKit\OptionCollection;
use \GetOptionKit\OptionParser;
use \GetOptionKit\OptionPrinter\ConsoleOptionPrinter;

echo 'testphase v' . Testphase::VERSION . PHP_EOL;

$cwd = getcwd();
//echo "cdw: $cwd" . PHP_EOL;

$specs = new OptionCollection;
$specs->add('d|dir:', 'Tests directory path')
    ->isa('String');

$specs->add('s|subdir+', 'Optional, subdirectory pattern')
    ->isa('String')
    ->defaultValue(null);

$specs->add('b|bootstrap:', 'Bootstrap file path')
    ->isa('File');

$specs->add('show-globals', 'Show values of global variables')->defaultValue(false);
$specs->add('debug', 'Show debug messages')->defaultValue(false);
$specs->add('h|help', 'Show help')->defaultValue(false);
$specs->add('no-colors', 'No colors')->defaultValue(false);
$specs->add('i|immediate', 'Show error output immediately as it appears')->defaultValue(false);

$parser = new OptionParser($specs);
$arguments = $parser->parse($argv);

if ($arguments['help']->value) {
    echo 'Help:' . PHP_EOL;
    $printer = new ConsoleOptionPrinter;
    echo $printer->render($specs);
    return 0;
} elseif ($arguments['debug']->value) {
    echo 'Enabled options: ' . PHP_EOL;

    foreach ($arguments as $key => $spec) {
        echo $spec . PHP_EOL;
    }
}

$dir = $arguments['dir']->value;
$bootstrap = $arguments['bootstrap']->value;

require $bootstrap;

//Get all .json files in directory
$files = array_map(
    function ($f) {
        return str_replace('//', '/', $f);
    },
    Util::directoryToArray(
        $dir,
        true,
        false,
        true,
        '/^\.|\.\.$/',
        ['json'],
        false
    )
);

/**
 * @var TestParser
 */
$tests = [];

foreach ($files as $filename) {
    $testParser = new TestParser($filename);
    $tests[] = $testParser;
}

function cmp($a, $b)
{
    return ($a->getMeta()->order < $b->getMeta()->order ? -1 : 1);
}

//Sort tests by order
uasort($tests, 'cmp');

//Statistics object
$stats = (object)[
    'tests' => count($tests),
    'success' => 0,
    'error' => 0,
    'ignore' => 0,
    'errors' => []
];

$i=0;

//Execute tests
foreach ($tests as $test) {
    //Check if subdir argument is set
    if (isset($arguments['subdir']) && $arguments['subdir']->value !== null) {
        //If so check if file name passes the given pattern

        //Remove base dir from filename
        $cleanFilename = trim(
            str_replace(
                $arguments['dir']->value,
                '',
                $test->getFilename()
            ),
            '/'
        );

        $match = false;

        //Check if any of the patterns ar matching
        foreach ($arguments['subdir']->value as $pattern) {
            $pattern = '@' . $pattern . '@';
            if (!!preg_match($pattern, $cleanFilename)) {
                $match = $match || true;
                break;
            }
        }

        if (!$match) {
            $stats->ignore += 1;
            echo 'I';
            continue;
        }
    }

    $meta = $test->getMeta();

    if (isset($meta->ignore) && $meta->ignore) {
        $stats->ignore += 1;
        echo 'I';
        continue;
    }

    $test->createTest();

    try {
        $ok = $test->getTest()->run(function (
            $responseStatusCode,
            $responseHeaders,
            $responseBody,
            $responseBodyObject
        ) {
            global $arguments;
            global $test;

            $export = $test->getExport();

            //Fetch all teest exports and add them as globals
            foreach ($export as $key => $value) {
                $path = explode('.', $value);

                $pathValue = $responseBodyObject;

                foreach ($path as $p) {
                    $arrayIndex = 0;

                    if (is_array($pathValue)) {
                        $pathValue = $pathValue[$arrayIndex]->{$p};
                    } else {
                        $pathValue = $pathValue->{$p};
                    }

                }

                TestParser::addGlobal($key, $pathValue);
            }

            if ($arguments['debug']->value) {
                echo 'Response Status Code:' . PHP_EOL;
                echo $responseStatusCode . PHP_EOL;
                echo 'Response Headers:' . PHP_EOL;
                print_r($responseHeaders);
                echo PHP_EOL;
                echo 'Response Body:' . PHP_EOL;
                echo json_encode($responseBodyObject, JSON_PRETTY_PRINT) . PHP_EOL;
            }
        });

        //Echo successful char
        echo '.';
        $stats->success += 1;
    } catch (\Exception $e) {
        //@todo if verbose show more details (trace)
        $message = $e->getMessage();

        if ($arguments['debug']) {
            $message .= PHP_EOL . $test->getTest()->getResponseBody();
        }
        $message = sprintf(
            colored('Test "%s" failed with message', 'red') . PHP_EOL . ' %s' . PHP_EOL,
            $test->getFilename(),
            $message
        );
        $stats->errors[] = $message;

        if ($arguments['immediate']) {
            echo $message . PHP_EOL;
        }


        //Echo unsuccessful char
        echo 'E';
        $stats->error += 1;
    }
    ++$i;
    //Allow only 80 characters per line
    if (!($i % 79)) {
        echo PHP_EOL;
    }
}
echo PHP_EOL;

if ($arguments['show-globals']->value) {
    echo 'Globals:' . PHP_EOL;
    print_r(TestParser::getGlobal());
}

if (!$arguments['immediate']) {
    foreach ($stats->errors as $e) {
        echo $e . PHP_EOL;
    }
}

echo 'Complete!' . PHP_EOL;
echo 'Tests:' . $stats->tests . ', ';
output('Successful: ' . $stats->success, 'green');
echo ', ';
output('Ignored: ' . $stats->ignore, 'yellow');
echo ', ';
output('Unsuccessful: ' . $stats->error . PHP_EOL, 'red');

function colored($text, $color)
{
    $colors = [
        'black' => '0;30',
        'red' => '0;31',
        'green' => '0;32',
        'blue' => '1;34',
        'yellow' => '1;33'
    ];

    $c = array_key_exists($color, $colors) ? $colors[$color] : $colors['black'];

    global $arguments;
    if ($arguments['no-colors']->value) {
        return $text;
    } else {
        return "\033[". $c . "m" . $text . "\033[0m";
    }
}
function output($text, $color)
{
    echo colored($text, $color);
}

if ($stats->error > 0) {
    return (1);
}
return 0;
